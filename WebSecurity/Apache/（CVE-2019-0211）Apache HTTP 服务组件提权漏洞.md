# （CVE-2019-0211）Apache HTTP 服务组件提权漏洞

## 一、漏洞简介

在Apache HTTP Server 2.4发行版2.4.17到2.4.38中，无论是使用Apache HTTP Server 的MPM event模式、还是worker或prefork模式，在低权限的子进程或线程中执行的代码(包括由进程内脚本解释器执行的脚本)可以通过操纵记分牌（scoreboard）来执行具有父进程(通常是Root进程)权限的任意代码。非unix系统则不受影响。

## 二、漏洞影响

Apache HTTP Server 2.4.17-2.4.38

## 三、复现过程

### 漏洞分析

1.恶意用户首先修改bucket,并使其指向恶意构造的prefork_child_bucket结构（共享内存中）。

2.优雅重启

主服务进程会杀死以前所有的工作进程，然后调用prefork_run，fork出新的工作进程

```c
<server/mpm/prefork/prefork.c>

//省略无关的部分

static int prefork_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
{
    int index;
    int remaining_children_to_start;
    int i;

    ap_log_pid(pconf, ap_pid_fname);

    if (!retained->mpm->was_graceful) {//跳过，因为优雅启动时，was_graceful为true
        if (ap_run_pre_mpm(s->process->pool, SB_SHARED) != OK) {
            retained->mpm->mpm_state = AP_MPMQ_STOPPING;
            return !OK;
        }
        /* fix the generation number in the global score; we just got a new,
         * cleared scoreboard
         */
        ap_scoreboard_image->global->running_generation = retained->mpm->my_generation;
    }
...
    if (!retained->mpm->was_graceful) {
        startup_children(remaining_children_to_start);
        remaining_children_to_start = 0;
    }
...
    while (!retained->mpm->restart_pending && !retained->mpm->shutdown_pending) {
...
        ap_wait_or_timeout(&exitwhy, &status, &pid, pconf, ap_server_conf);//获取被杀死的工作进程的PID
...
        if (pid.pid != -1) {
            processed_status = ap_process_child_status(&pid, exitwhy, status);
            child_slot = ap_find_child_by_pid(&pid);//获取PID对应于计分板中对应parent的下标
...
            /* non-fatal death... note that it's gone in the scoreboard. */
            if (child_slot >= 0) {
                (void) ap_update_child_status_from_indexes(child_slot, 0, SERVER_DEAD,
                                                           (request_rec *) NULL);
                prefork_note_child_killed(child_slot, 0, 0);
                if (processed_status == APEXIT_CHILDSICK) {
                    /* child detected a resource shortage (E[NM]FILE, ENOBUFS, etc)
                     * cut the fork rate to the minimum
                     */
                    retained->idle_spawn_rate = 1;
                }
                else if (remaining_children_to_start
                    && child_slot < ap_daemons_limit) {//如果工作进程的死亡不是致命的
                    /* we're still doing a 1-for-1 replacement of dead
                     * children with new children
                     */
                    make_child(ap_server_conf, child_slot,
                               ap_get_scoreboard_process(child_slot)->bucket);//则将死亡的工作进程的bucket作为参数传递（注意：bucket我们可以用“非常规手段”进行修改，从而提权）
                    --remaining_children_to_start;
                }
            }
    }
    return OK;
}
make_child：
static int make_child(server_rec *s, int slot, int bucket)
{
...
    if (!pid) {
        my_bucket = &all_buckets[bucket];//使my_bucket指向共享内存中的到恶意构造的prefork_child_bucket结构
...
        child_main(slot, bucket);
...    
    return 0;
}
static void child_main(int child_num_arg, int child_bucket)
{
...
    status = SAFE_ACCEPT(apr_proc_mutex_child_init(&my_bucket->mutex,
                                    apr_proc_mutex_lockfile(my_bucket->mutex),
                                    pchild));//如果Apache侦听两个或更多端口，则SAFE_ACCEPT（<code>）将仅执行<code>(这通常是因为服务器侦听HTTP（80）和HTTPS（443）)
...
}
APR_DECLARE(apr_status_t) apr_proc_mutex_child_init(apr_proc_mutex_t **mutex,
                                                    const char *fname,
                                                    apr_pool_t *pool)
{
    return (*mutex)->meth->child_init(mutex, pool, fname);
}
```

如果apr_proc_mutex_child_init执行，这导致（* mutex） - > meth-> child_init（mutex，pool，fname）被调用，从而执行恶意代码（注意，执行恶意代码的时候，进程仍然处于root权限，后面才降低自身的权限）。

### 通过gdb恶意修改bucket值造成的崩溃

```
(gdb) 
716            child_main(slot, bucket);
(gdb) s
child_main (child_num_arg=child_num_arg@entry=0, child_bucket=child_bucket@entry=80808080) at prefork.c:380
380    {
(gdb) n
..........
432        status = SAFE_ACCEPT(apr_proc_mutex_child_init(&my_bucket->mutex,
(gdb) s

Program received signal SIGSEGV, Segmentation fault.
0x000000000046c16b in child_main (child_num_arg=child_num_arg@entry=0, 
    child_bucket=child_bucket@entry=80808080) at prefork.c:432
432        status = SAFE_ACCEPT(apr_proc_mutex_child_init(&my_bucket->mutex,
```

### 利用

利用分4个步骤

- 获得工作进程的R/W访问权限

- 在共享内存中写一个假的prefork_child_bucket结构

- 使all_buckets [bucket]指向该结构

- 等待早上6:25获得任意函数调用

问题：PHP不允许读写/proc/self/mem， 这会阻止我们利用简单方法编辑共享内存

### 获取工作进程内存的R/W访问权限
PHP UAF 0-day
